'use strict';

const node_fs = require('node:fs');
const kit = require('@nuxt/kit');
const defu = require('defu');
const magicast = require('magicast');
const esbuild = require('esbuild');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const NAME = "vue-query-nuxt";
const configKey = "vueQuery";
const composables = [
  "useQuery",
  "useQueries",
  "useInfiniteQuery",
  "useMutation",
  "useIsFetching",
  "useIsMutating",
  "useQueryClient"
];
const defaults = {
  stateKey: NAME,
  autoImports: [...composables],
  queryClientOptions: {
    defaultOptions: { queries: { staleTime: 5e3 } }
  },
  vueQueryPluginOptions: {}
};

const module$1 = kit.defineNuxtModule({
  meta: {
    name: NAME,
    configKey,
    compatibility: {
      nuxt: "^3"
    }
  },
  defaults,
  async setup(userOptions, nuxt) {
    const logger = kit.useLogger(NAME);
    const { resolve } = kit.createResolver((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('module.cjs', document.baseURI).href)));
    logger.info(`Adding ${NAME} module...`);
    nuxt.options.runtimeConfig.public[configKey] = defu.defu(nuxt.options.runtimeConfig.public[configKey], userOptions, {});
    kit.addPlugin(resolve("./runtime/plugin"));
    kit.addImports([{ name: "defineVueQueryPluginHook", from: resolve("./runtime/composables/defineVueQueryPluginHook") }]);
    const filename = "internal.vue-query-plugin-hook.mjs";
    kit.addTemplate({
      filename,
      write: true,
      getContents: async () => {
        if (node_fs.existsSync(resolve(nuxt.options.rootDir, "vue-query.config.ts"))) {
          const configFile = resolve(nuxt.options.rootDir, "vue-query.config.ts");
          const file = await magicast.loadFile(configFile);
          if (file.exports.pluginHook || file.exports.default) {
            logger.success("Found vue-query.config.ts file");
            if (!file.exports.pluginHook)
              file.exports.pluginHook = file.exports.default;
            delete file.exports.default;
            const { code } = magicast.generateCode(file);
            const shaked = await esbuild.transform(code, { treeShaking: true, loader: "ts" });
            return shaked.code;
          } else {
            logger.error("Found vue-query.config.ts file, but it does not export a `pluginHook`.");
          }
        } else {
          logger.info("No vue-query.config.ts file found.");
        }
        return "export function pluginHook() { return { pluginReturn: null, vueQueryPluginOptions: null}}";
      }
    });
    kit.addTypeTemplate({
      filename: "types/vue-query-nuxt-advanced.d.ts",
      write: true,
      getContents: () => `
      type PluginHookResult = Awaited<ReturnType<typeof import(".nuxt/${filename}").pluginHook>["pluginReturn"]>

      type AddDollarPrefix<T> = {
        [K in keyof T['provide'] as \`$\${string & K}\`]: T['provide'][K]
      }

      declare module '#app' {
        interface NuxtApp extends AddDollarPrefix<PluginHookResult> {}
      }
      export { }`
    });
    nuxt.hook("builder:watch", async (event, path) => {
      if (path.includes("vue-query.config.ts")) {
        logger.info(`[vue-query] config changed '@${event}'`, path);
        kit.updateTemplates({ filter: (t) => t.filename === filename });
        logger.success("[vue-query] config reloaded.");
      }
    });
    if (userOptions.autoImports && userOptions.autoImports.length > 0)
      kit.addImports(userOptions.autoImports.map((name) => ({ name, from: "@tanstack/vue-query" })));
    logger.success(`Added ${NAME} module successfully.`);
  }
});

module.exports = module$1;
